/* 130. 被围绕的区域解题思路从边界入手，边界的O以及与其相连的O都不变，内部的O要变成1编程过程参考了优秀题解：1，dfs递归，而非bfs2，dfs时把是O但不需要变的先暂时变成#，避免使用visited数组表示已访问过3，直接传递board，没有修改状态和恢复状态的操作。*/class Solution {    public void solve(char[][] board) {        int m = board.length;        int n = board[0].length;        for(int i=0;i<m;i++){            for(int j=0;j<n;j++){                if(i==0 || i==m-1 || j==0 || j==n-1){                    if(board[i][j]=='O'){                        dfs(i,j,board);                    }                }            }        }        for(int i=0;i<m;i++){            for(int j=0;j<n;j++){                if(board[i][j]=='O'){                    board[i][j]='X';                }                if(board[i][j]=='#'){                    board[i][j]='O';                }            }        }    }    void dfs(int i, int j, char[][]board){        if(i<0 || i>=board.length || j<0 || j>=board[0].length){            return;        }        if(board[i][j]=='O'){            board[i][j]='#';            dfs(i+1,j,board);            dfs(i-1,j,board);            dfs(i,j+1,board);            dfs(i,j-1,board);        }    }}/*  355. 设计推特本题主要就是高级数据结构的应用Pair<Integer, Integer> : userId发表 tweetIdtweets = new ArrayList<Pair<Integer, Integer>>();  顺序队列，发表的tweet加在队尾following = new HashMap<Integer,HashSet<Integer>>();   HashSet是一个用户关注的所有对象*/class Twitter {    List<Pair<Integer, Integer>> tweets;    Map<Integer, HashSet<Integer>> following;    public Twitter() {        tweets = new ArrayList<Pair<Integer, Integer>>();        following = new HashMap<Integer,HashSet<Integer>>();    }        public void postTweet(int userId, int tweetId) {        tweets.add(new Pair<Integer,Integer>(userId,tweetId));    }        public List<Integer> getNewsFeed(int userId) {        List<Integer> feeds = new ArrayList();        int len = tweets.size();        int cnt = 0;        for(int i=len-1; i>=0;i--){            boolean isUser=false;            if(tweets.get(i).getKey()==userId){                isUser = true;            }            boolean isFollowee=false;            if(following.containsKey(userId)){                if(following.get(userId).contains(tweets.get(i).getKey())){                    isFollowee=true;                }            }             if(isUser || isFollowee){                feeds.add(tweets.get(i).getValue());                cnt++;            }             if(cnt==10){                break;            }        }        return feeds;    }        public void follow(int followerId, int followeeId) {        if(following.containsKey(followerId)){            HashSet followees = following.get(followerId);            followees.add(followeeId);            following.put(followerId,followees);        }else{            HashSet followees = new HashSet();            followees.add(followeeId);            following.put(followerId, followees);        }    }        public void unfollow(int followerId, int followeeId) {        if(following.containsKey(followerId)){            if(following.get(followerId).contains(followeeId)){                following.get(followerId).remove(followeeId);            }        }    }}/* 538. 把二叉搜索树转换为累加树二叉搜索树中序遍历：递归处理root.left，root，递归处理root.right ⇒ val升序处理二叉搜索树反中序遍历： 递归处理root.right，root，递归处理root.left ⇒ val降序处理注意不要混淆树的后序遍历：root.left, root.right, root以及树的前序遍历：root, root.left, root.right */class Solution {    int sum=0;    public TreeNode convertBST(TreeNode root) {        if(root==null){            return null;        }        convertBST(root.right);        sum+=root.val;        root.val=sum;        convertBST(root.left);        return root;    }}