/* 130. 被围绕的区域解题思路从边界入手，边界的O以及与其相连的O都不变，内部的O要变成1编程过程参考了优秀题解：1，dfs递归，而非bfs2，dfs时把是O但不需要变的先暂时变成#，避免使用visited数组表示已访问过3，直接传递board，没有修改状态和恢复状态的操作。*/class Solution {    public void solve(char[][] board) {        int m = board.length;        int n = board[0].length;        for(int i=0;i<m;i++){            for(int j=0;j<n;j++){                if(i==0 || i==m-1 || j==0 || j==n-1){                    if(board[i][j]=='O'){                        dfs(i,j,board);                    }                }            }        }        for(int i=0;i<m;i++){            for(int j=0;j<n;j++){                if(board[i][j]=='O'){                    board[i][j]='X';                }                if(board[i][j]=='#'){                    board[i][j]='O';                }            }        }    }    void dfs(int i, int j, char[][]board){        if(i<0 || i>=board.length || j<0 || j>=board[0].length){            return;        }        if(board[i][j]=='O'){            board[i][j]='#';            dfs(i+1,j,board);            dfs(i-1,j,board);            dfs(i,j+1,board);            dfs(i,j-1,board);        }    }}